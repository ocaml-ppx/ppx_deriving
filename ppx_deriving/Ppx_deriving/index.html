<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ppx_deriving (ppx_deriving.Ppx_deriving)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">ppx_deriving</a> &#x00BB; Ppx_deriving</nav><h1>Module <code>Ppx_deriving</code></h1><p>Public API of <code>ppx_deriving</code> executable.</p><nav class="toc"><ul><li><a href="#registration">Registration</a></li><li><a href="#coercions">Coercions</a></li><li><a href="#option-parsing">Option parsing</a></li><li><a href="#hygiene">Hygiene</a></li><li><a href="#ast-manipulation">AST manipulation</a></li><li><a href="#miscellanea">Miscellanea</a></li></ul></nav></header><dl><dt class="spec type" id="type-tyvar"><a href="#type-tyvar" class="anchor"></a><code><span class="keyword">type</span> tyvar</code><code> = <span>string Ppxlib.Location.loc</span></code></dt></dl><section><header><h3 id="registration"><a href="#registration" class="anchor"></a>Registration</h3></header><dl><dt class="spec type" id="type-deriver"><a href="#type-deriver" class="anchor"></a><code><span class="keyword">type</span> deriver</code><code> = </code><code>{</code><table class="record"><tr id="type-deriver.name" class="anchored"><td class="def field"><a href="#type-deriver.name" class="anchor"></a><code>name : string;</code></td></tr><tr id="type-deriver.core_type" class="anchored"><td class="def field"><a href="#type-deriver.core_type" class="anchor"></a><code>core_type : <span><span>(Ppxlib.core_type <span>&#45;&gt;</span> Ppxlib.expression)</span> option</span>;</code></td></tr><tr id="type-deriver.type_decl_str" class="anchored"><td class="def field"><a href="#type-deriver.type_decl_str" class="anchor"></a><code>type_decl_str : <span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> <span>Ppxlib.type_declaration list</span> <span>&#45;&gt;</span> Ppxlib.structure;</code></td></tr><tr id="type-deriver.type_ext_str" class="anchored"><td class="def field"><a href="#type-deriver.type_ext_str" class="anchor"></a><code>type_ext_str : <span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> Ppxlib.type_extension <span>&#45;&gt;</span> Ppxlib.structure;</code></td></tr><tr id="type-deriver.module_type_decl_str" class="anchored"><td class="def field"><a href="#type-deriver.module_type_decl_str" class="anchor"></a><code>module_type_decl_str : <span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> Ppxlib.module_type_declaration <span>&#45;&gt;</span> Ppxlib.structure;</code></td></tr><tr id="type-deriver.type_decl_sig" class="anchored"><td class="def field"><a href="#type-deriver.type_decl_sig" class="anchor"></a><code>type_decl_sig : <span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> <span>Ppxlib.type_declaration list</span> <span>&#45;&gt;</span> Ppxlib.signature;</code></td></tr><tr id="type-deriver.type_ext_sig" class="anchored"><td class="def field"><a href="#type-deriver.type_ext_sig" class="anchor"></a><code>type_ext_sig : <span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> Ppxlib.type_extension <span>&#45;&gt;</span> Ppxlib.signature;</code></td></tr><tr id="type-deriver.module_type_decl_sig" class="anchored"><td class="def field"><a href="#type-deriver.module_type_decl_sig" class="anchor"></a><code>module_type_decl_sig : <span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> Ppxlib.module_type_declaration <span>&#45;&gt;</span> Ppxlib.signature;</code></td></tr></table><code>}</code></dt><dd><p>A type of deriving plugins.</p><p>A structure or signature deriving function accepts a list of <code>~options</code>, a <code>~path</code> of modules for the type declaration currently being processed (with <code>[]</code> for toplevel phrases), and a type declaration item (<code>type t = .. and t' = ..</code>), and returns a list of items to be appended after the type declaration item in structure and signature. It is invoked by <code>[\@\@deriving]</code> annotations.</p><p>A type deriving function accepts a type and returns a corresponding derived expression. It is invoked by <code>[%derive.foo:]</code> and <code>[%foo:]</code> annotations. If this function is missing, the corresponding <code>[%foo:]</code> annotation is ignored.</p><p>The structure and signature deriving functions are invoked in the order in which they appear in the source code.</p></dd></dl><dl><dt class="spec value" id="val-register"><a href="#val-register" class="anchor"></a><code><span class="keyword">val</span> register : <a href="index.html#type-deriver">deriver</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>register deriver</code> registers <code>deriver</code> according to its <code>name</code> field.</p></dd></dl><dl><dt class="spec value" id="val-add_register_hook"><a href="#val-add_register_hook" class="anchor"></a><code><span class="keyword">val</span> add_register_hook : <span>(<a href="index.html#type-deriver">deriver</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_register_hook hook</code> adds <code>hook</code> to be executed whenever a new deriver is registered.</p></dd></dl><dl><dt class="spec value" id="val-derivers"><a href="#val-derivers" class="anchor"></a><code><span class="keyword">val</span> derivers : unit <span>&#45;&gt;</span> <span><a href="index.html#type-deriver">deriver</a> list</span></code></dt><dd><p><code>derivers ()</code> returns all currently registered derivers.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : string <span>&#45;&gt;</span> <span>?&#8288;core_type:<span>(Ppxlib.core_type <span>&#45;&gt;</span> Ppxlib.expression)</span></span> <span>&#45;&gt;</span> <span>?&#8288;type_ext_str:<span>(<span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> Ppxlib.type_extension <span>&#45;&gt;</span> Ppxlib.structure)</span></span> <span>&#45;&gt;</span> <span>?&#8288;type_ext_sig:<span>(<span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> Ppxlib.type_extension <span>&#45;&gt;</span> Ppxlib.signature)</span></span> <span>&#45;&gt;</span> <span>?&#8288;type_decl_str:<span>(<span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> <span>Ppxlib.type_declaration list</span> <span>&#45;&gt;</span> Ppxlib.structure)</span></span> <span>&#45;&gt;</span> <span>?&#8288;type_decl_sig:<span>(<span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> <span>Ppxlib.type_declaration list</span> <span>&#45;&gt;</span> Ppxlib.signature)</span></span> <span>&#45;&gt;</span> <span>?&#8288;module_type_decl_str:<span>(<span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> Ppxlib.module_type_declaration <span>&#45;&gt;</span> Ppxlib.structure)</span></span> <span>&#45;&gt;</span> <span>?&#8288;module_type_decl_sig:<span>(<span>options:<span><span>(string * Ppxlib.expression)</span> list</span></span> <span>&#45;&gt;</span> <span>path:<span>string list</span></span> <span>&#45;&gt;</span> Ppxlib.module_type_declaration <span>&#45;&gt;</span> Ppxlib.signature)</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-deriver">deriver</a></code></dt><dd><p>Creating <a href="index.html#type-deriver"><code>deriver</code></a> structure.</p></dd></dl><dl><dt class="spec value" id="val-lookup"><a href="#val-lookup" class="anchor"></a><code><span class="keyword">val</span> lookup : string <span>&#45;&gt;</span> <span><a href="index.html#type-deriver">deriver</a> option</span></code></dt><dd><p><code>lookup name</code> looks up a deriver called <code>name</code>.</p></dd></dl><dl><dt class="spec value" id="val-raise_errorf"><a href="#val-raise_errorf" class="anchor"></a><code><span class="keyword">val</span> raise_errorf : <span>?&#8288;sub:<span>Ocaml_common.Location.error list</span></span> <span>&#45;&gt;</span> <span>?&#8288;loc:Ppxlib.Location.t</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, unit, string, <span class="type-var">'b</span>)</span> Stdlib.format4</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><h3 id="error-handling"><a href="#error-handling" class="anchor"></a>Error handling</h3></dd></dl></section><section><header><h3 id="coercions"><a href="#coercions" class="anchor"></a>Coercions</h3></header><dl><dt class="spec value" id="val-string_of_core_type"><a href="#val-string_of_core_type" class="anchor"></a><code><span class="keyword">val</span> string_of_core_type : Ppxlib.Parsetree.core_type <span>&#45;&gt;</span> string</code></dt><dd><p><code>string_of_core_type typ</code> unparses <code>typ</code>, omitting any attributes.</p></dd></dl><dl><dt class="spec value" id="val-string_of_constant_opt"><a href="#val-string_of_constant_opt" class="anchor"></a><code><span class="keyword">val</span> string_of_constant_opt : Ppxlib.Parsetree.constant <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p><code>string_of_constant_opt c</code> returns <code>Some s</code> if the constant <code>c</code> is a string <code>s</code>, <code>None</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-string_of_expression_opt"><a href="#val-string_of_expression_opt" class="anchor"></a><code><span class="keyword">val</span> string_of_expression_opt : Ppxlib.Parsetree.expression <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p><code>string_of_expression_opt e</code> returns <code>Some s</code> if the expression <code>e</code> is a string constant <code>s</code>, <code>None</code> otherwise.</p></dd></dl></section><section><header><h3 id="option-parsing"><a href="#option-parsing" class="anchor"></a>Option parsing</h3></header><dl><dt class="spec module" id="module-Arg"><a href="#module-Arg" class="anchor"></a><code><span class="keyword">module</span> <a href="Arg/index.html">Arg</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><a href="Arg/index.html"><code>Arg</code></a> contains convenience functions that extract constants from AST fragments, to be used when parsing options or <code>[\@attributes]</code> attached to types, fields or constructors.</p></dd></dl></section><section><header><h3 id="hygiene"><a href="#hygiene" class="anchor"></a>Hygiene</h3></header><dl><dt class="spec type" id="type-quoter"><a href="#type-quoter" class="anchor"></a><code><span class="keyword">type</span> quoter</code></dt><dd><p>A <code>quoter</code> remembers a set of expressions.</p></dd></dl><dl><dt class="spec value" id="val-create_quoter"><a href="#val-create_quoter" class="anchor"></a><code><span class="keyword">val</span> create_quoter : unit <span>&#45;&gt;</span> <a href="index.html#type-quoter">quoter</a></code></dt><dd><p><code>quoter ()</code> creates an empty quoter.</p></dd></dl><dl><dt class="spec value" id="val-quote"><a href="#val-quote" class="anchor"></a><code><span class="keyword">val</span> quote : <span>quoter:<a href="index.html#type-quoter">quoter</a></span> <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>quote quoter expr</code> records a pure expression <code>expr</code> within <code>quoter</code> and returns an expression which has the same value as <code>expr</code> in the context that <code>sanitize</code> provides.</p></dd></dl><dl><dt class="spec value" id="val-sanitize"><a href="#val-sanitize" class="anchor"></a><code><span class="keyword">val</span> sanitize : <span>?&#8288;module_:Ppxlib.Longident.t</span> <span>&#45;&gt;</span> <span>?&#8288;quoter:<a href="index.html#type-quoter">quoter</a></span> <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>sanitize module_ quoter expr</code> wraps <code>expr</code> in a way that ensures that the contents of <code>module_</code> and <code>Pervasives</code>, as well as the identifiers in expressions returned by <code>quote</code> are in scope, and returns the wrapped expression. <code>module_</code> defaults to <a href="../Ppx_deriving_runtime/index.html"><code>Ppx_deriving_runtime</code></a> if it's not provided</p></dd></dl><dl><dt class="spec value" id="val-with_quoter"><a href="#val-with_quoter" class="anchor"></a><code><span class="keyword">val</span> with_quoter : <span>(<a href="index.html#type-quoter">quoter</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Ppxlib.expression)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>with_quoter fn</code> ≡ <code>fun fn a -&gt; let quoter = create_quoter () in sanitize ~quoter (fn quoter a)</code></p></dd></dl></section><section><header><h3 id="ast-manipulation"><a href="#ast-manipulation" class="anchor"></a>AST manipulation</h3></header><dl><dt class="spec value" id="val-expand_path"><a href="#val-expand_path" class="anchor"></a><code><span class="keyword">val</span> expand_path : <span>path:<span>string list</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>expand_path name</code> returns <code>name</code> with the <code>path</code> module path prepended, e.g. <code>expand_path [&quot;Foo&quot;;&quot;M&quot;] &quot;t&quot;</code> = <code>&quot;Foo.M.t&quot;</code> and <code>expand_path [] &quot;t&quot;</code> = <code>&quot;t&quot;</code></p></dd></dl><dl><dt class="spec value" id="val-path_of_type_decl"><a href="#val-path_of_type_decl" class="anchor"></a><code><span class="keyword">val</span> path_of_type_decl : <span>path:<span>string list</span></span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> <span>string list</span></code></dt><dd><p><code>path_of_type_decl ~path type_</code> returns <code>path</code> if <code>type_</code> does not have a manifest or the manifest is not a constructor, and the module path of manifest otherwise.</p><p><code>path_of_type_decl</code> is useful when determining the canonical path location of fields and constructors; e.g. for <code>type bar = M.foo = A | B</code>, it will return <code>[&quot;M&quot;]</code>.</p></dd></dl><dl><dt class="spec value" id="val-mangle_type_decl"><a href="#val-mangle_type_decl" class="anchor"></a><code><span class="keyword">val</span> mangle_type_decl : <span>?&#8288;fixpoint:string</span> <span>&#45;&gt;</span> <span>[ <span>`Prefix of string</span> <span><span>| `Suffix</span> of string</span> <span><span>| `PrefixSuffix</span> of string * string</span> ]</span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> string</code></dt><dd><p><code>mangle_type_decl ~fixpoint affix type_</code> derives a function name from <code>type_</code> name by doing nothing if <code>type_</code> is named <code>fixpoint</code> (<code>&quot;t&quot;</code> by default), or appending and/or prepending <code>affix</code> via an underscore.</p></dd></dl><dl><dt class="spec value" id="val-mangle_lid"><a href="#val-mangle_lid" class="anchor"></a><code><span class="keyword">val</span> mangle_lid : <span>?&#8288;fixpoint:string</span> <span>&#45;&gt;</span> <span>[ <span>`Prefix of string</span> <span><span>| `Suffix</span> of string</span> <span><span>| `PrefixSuffix</span> of string * string</span> ]</span> <span>&#45;&gt;</span> Ppxlib.Longident.t <span>&#45;&gt;</span> Ppxlib.Longident.t</code></dt><dd><p><code>mangle_lid ~fixpoint affix lid</code> does the same as <a href="index.html#val-mangle_type_decl"><code>mangle_type_decl</code></a>, but for the last component of <code>lid</code>.</p></dd></dl><dl><dt class="spec value" id="val-attr"><a href="#val-attr" class="anchor"></a><code><span class="keyword">val</span> attr : <span>deriver:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> Ppxlib.attributes <span>&#45;&gt;</span> <span>Ppxlib.attribute option</span></code></dt><dd><p><code>attr ~deriver name attrs</code> searches for an attribute <code>[\@deriving.deriver.attr]</code> in <code>attrs</code> if any attribute with name starting with <code>\@deriving.deriver</code> exists, or <code>[\@deriver.attr]</code> if any attribute with name starting with <code>\@deriver</code> exists, or <code>[\@attr]</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-attr_warning"><a href="#val-attr_warning" class="anchor"></a><code><span class="keyword">val</span> attr_warning : Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.attribute</code></dt><dd><p><code>attr_warning expr</code> builds the attribute <code>\@ocaml.warning expr</code></p></dd></dl><dl><dt class="spec value" id="val-free_vars_in_core_type"><a href="#val-free_vars_in_core_type" class="anchor"></a><code><span class="keyword">val</span> free_vars_in_core_type : Ppxlib.core_type <span>&#45;&gt;</span> <span><a href="index.html#type-tyvar">tyvar</a> list</span></code></dt><dd><p><code>free_vars_in_core_type typ</code> returns unique free variables in <code>typ</code> in lexical order.</p></dd></dl><dl><dt class="spec value" id="val-remove_pervasives"><a href="#val-remove_pervasives" class="anchor"></a><code><span class="keyword">val</span> remove_pervasives : <span>deriver:string</span> <span>&#45;&gt;</span> Ppxlib.core_type <span>&#45;&gt;</span> Ppxlib.core_type</code></dt><dd><p><code>remove_pervasives ~deriver typ</code> removes the leading &quot;Pervasives.&quot; module name in longidents. Type expressions marked with <code>[\@nobuiltin]</code> are ignored.</p><p>The name of the deriving plugin should be passed as <code>deriver</code>; it is used in error messages.</p></dd></dl><dl><dt class="spec value" id="val-fresh_var"><a href="#val-fresh_var" class="anchor"></a><code><span class="keyword">val</span> fresh_var : <span>string list</span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>fresh_var bound</code> returns a fresh variable name not present in <code>bound</code>. The name is selected in alphabetical succession.</p></dd></dl><dl><dt class="spec value" id="val-fold_left_type_decl"><a href="#val-fold_left_type_decl" class="anchor"></a><code><span class="keyword">val</span> fold_left_type_decl : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-tyvar">tyvar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left_type_decl fn accum type_</code> performs a left fold over all type variable (i.e. not wildcard) parameters in <code>type_</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right_type_decl"><a href="#val-fold_right_type_decl" class="anchor"></a><code><span class="keyword">val</span> fold_right_type_decl : <span>(<a href="index.html#type-tyvar">tyvar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_right_type_decl fn accum type_</code> performs a right fold over all type variable (i.e. not wildcard) parameters in <code>type_</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_left_type_ext"><a href="#val-fold_left_type_ext" class="anchor"></a><code><span class="keyword">val</span> fold_left_type_ext : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-tyvar">tyvar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Ppxlib.type_extension <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left_type_ext fn accum type_</code> performs a left fold over all type variable (i.e. not wildcard) parameters in <code>type_</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right_type_ext"><a href="#val-fold_right_type_ext" class="anchor"></a><code><span class="keyword">val</span> fold_right_type_ext : <span>(<a href="index.html#type-tyvar">tyvar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> Ppxlib.type_extension <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_right_type_ext fn accum type_</code> performs a right fold over all type variable (i.e. not wildcard) parameters in <code>type_</code>.</p></dd></dl><dl><dt class="spec value" id="val-poly_fun_of_type_decl"><a href="#val-poly_fun_of_type_decl" class="anchor"></a><code><span class="keyword">val</span> poly_fun_of_type_decl : Ppxlib.type_declaration <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>poly_fun_of_type_decl type_ expr</code> wraps <code>expr</code> into <code>fun poly_N -&gt; ...</code> for every type parameter <code>'N</code> present in <code>type_</code>. For example, if <code>type_</code> refers to <code>type ('a, 'b) map</code>, <code>expr</code> will be wrapped into <code>fun poly_a poly_b -&gt; [%e expr]</code>.</p><p><code>_</code> parameters are ignored.</p></dd></dl><dl><dt class="spec value" id="val-poly_fun_of_type_ext"><a href="#val-poly_fun_of_type_ext" class="anchor"></a><code><span class="keyword">val</span> poly_fun_of_type_ext : Ppxlib.type_extension <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p>Same as <a href="index.html#val-poly_fun_of_type_decl"><code>poly_fun_of_type_decl</code></a> but for type extension.</p></dd></dl><dl><dt class="spec value" id="val-poly_apply_of_type_decl"><a href="#val-poly_apply_of_type_decl" class="anchor"></a><code><span class="keyword">val</span> poly_apply_of_type_decl : Ppxlib.type_declaration <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>poly_apply_of_type_decl type_ expr</code> wraps <code>expr</code> into <code>expr poly_N</code> for every type parameter <code>'N</code> present in <code>type_</code>. For example, if <code>type_</code> refers to <code>type ('a, 'b) map</code>, <code>expr</code> will be wrapped into <code>[%e expr] poly_a poly_b</code>.</p><p><code>_</code> parameters are ignored.</p></dd></dl><dl><dt class="spec value" id="val-poly_apply_of_type_ext"><a href="#val-poly_apply_of_type_ext" class="anchor"></a><code><span class="keyword">val</span> poly_apply_of_type_ext : Ppxlib.type_extension <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p>Same as <a href="index.html#val-poly_apply_of_type_decl"><code>poly_apply_of_type_decl</code></a> but for type extension.</p></dd></dl><dl><dt class="spec value" id="val-poly_arrow_of_type_decl"><a href="#val-poly_arrow_of_type_decl" class="anchor"></a><code><span class="keyword">val</span> poly_arrow_of_type_decl : <span>(Ppxlib.core_type <span>&#45;&gt;</span> Ppxlib.core_type)</span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> Ppxlib.core_type <span>&#45;&gt;</span> Ppxlib.core_type</code></dt><dd><p><code>poly_arrow_of_type_decl fn type_ typ</code> wraps <code>typ</code> in an arrow with <code>fn [%type: 'N]</code> as argument for every type parameter <code>'N</code> present in <code>type_</code>. For example, if <code>type_</code> refers to <code>type ('a, 'b) map</code> and <code>fn</code> is <code>fun var -&gt; [%type: [%t var] -&gt; string]</code>, <code>typ</code> will be wrapped into <code>('a -&gt; string) -&gt; ('b -&gt; string) -&gt; [%t typ]</code>.</p><p><code>_</code> parameters are ignored.</p></dd></dl><dl><dt class="spec value" id="val-poly_arrow_of_type_ext"><a href="#val-poly_arrow_of_type_ext" class="anchor"></a><code><span class="keyword">val</span> poly_arrow_of_type_ext : <span>(Ppxlib.core_type <span>&#45;&gt;</span> Ppxlib.core_type)</span> <span>&#45;&gt;</span> Ppxlib.type_extension <span>&#45;&gt;</span> Ppxlib.core_type <span>&#45;&gt;</span> Ppxlib.core_type</code></dt><dd><p>Same as <a href="index.html#val-poly_arrow_of_type_decl"><code>poly_arrow_of_type_decl</code></a> but for type extension.</p></dd></dl><dl><dt class="spec value" id="val-core_type_of_type_decl"><a href="#val-core_type_of_type_decl" class="anchor"></a><code><span class="keyword">val</span> core_type_of_type_decl : Ppxlib.type_declaration <span>&#45;&gt;</span> Ppxlib.core_type</code></dt><dd><p><code>core_type_of_type_decl type_</code> constructs type <code>('a, 'b, ...) t</code> for type declaration <code>type ('a, 'b, ...) t = ...</code>.</p></dd></dl><dl><dt class="spec value" id="val-core_type_of_type_ext"><a href="#val-core_type_of_type_ext" class="anchor"></a><code><span class="keyword">val</span> core_type_of_type_ext : Ppxlib.type_extension <span>&#45;&gt;</span> Ppxlib.core_type</code></dt><dd><p>Same as <a href="index.html#val-core_type_of_type_decl"><code>core_type_of_type_decl</code></a> but for type extension.</p></dd></dl><dl><dt class="spec value" id="val-instantiate"><a href="#val-instantiate" class="anchor"></a><code><span class="keyword">val</span> instantiate : <span>string list</span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> Ppxlib.core_type * <span>string list</span> * <span>string list</span></code></dt><dd><p><code>instantiate bound type_</code> returns <code>typ, vars, bound'</code> where <code>typ</code> is a type instantiated from type declaration <code>type_</code>, <code>vars</code> ≡ <code>free_vars_in_core_type typ</code> and <code>bound'</code> ≡ <code>bound @ vars</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_exprs"><a href="#val-fold_exprs" class="anchor"></a><code><span class="keyword">val</span> fold_exprs : <span>?&#8288;unit:Ppxlib.expression</span> <span>&#45;&gt;</span> <span>(Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression)</span> <span>&#45;&gt;</span> <span>Ppxlib.expression list</span> <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>fold_exprs ~unit fn exprs</code> folds <code>exprs</code> using head of <code>exprs</code> as initial accumulator value, or <code>unit</code> if <code>exprs = []</code>.</p><p>See also <a href="index.html#val-seq_reduce"><code>seq_reduce</code></a> and <a href="index.html#val-binop_reduce"><code>binop_reduce</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-seq_reduce"><a href="#val-seq_reduce" class="anchor"></a><code><span class="keyword">val</span> seq_reduce : <span>?&#8288;sep:Ppxlib.expression</span> <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p>When <code>sep</code> is present: <code>seq_reduce</code> ≡ <code>fun x a b -&gt; [%expr [%e a]; [%e x]; [%e b]]</code>. When <code>sep</code> is missing: <code>seq_reduce</code> ≡ <code>fun a b -&gt; [%expr [%e a]; [%e b]]</code>.</p></dd></dl><dl><dt class="spec value" id="val-binop_reduce"><a href="#val-binop_reduce" class="anchor"></a><code><span class="keyword">val</span> binop_reduce : Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>binop_reduce</code> ≡ <code>fun x a b -&gt; [%expr [%e x] [%e a] [%e b]]</code>.</p></dd></dl><dl><dt class="spec value" id="val-strong_type_of_type"><a href="#val-strong_type_of_type" class="anchor"></a><code><span class="keyword">val</span> strong_type_of_type : Ppxlib.core_type <span>&#45;&gt;</span> Ppxlib.core_type</code></dt><dd><p><code>strong_type_of_type ty</code> transform a type ty to <code>freevars . ty</code>, giving a strong polymorphic type</p></dd></dl><aside><p>The mapper for the currently loaded deriving plugins. It is useful for recursively processing expression-valued attributes.</p></aside><div class="spec class" id="class-mapper"><a href="#class-mapper" class="anchor"></a><code><span class="keyword">class</span>  mapper : Ppxlib.Ast_traverse.map</code></div></section><section><header><h3 id="miscellanea"><a href="#miscellanea" class="anchor"></a>Miscellanea</h3></header><dl><dt class="spec value" id="val-hash_variant"><a href="#val-hash_variant" class="anchor"></a><code><span class="keyword">val</span> hash_variant : string <span>&#45;&gt;</span> int</code></dt><dd><p><code>hash_variant x</code> ≡ <code>Btype.hash_variant x</code>.</p></dd></dl><div class="spec module" id="module-Ast_convenience"><a href="#module-Ast_convenience" class="anchor"></a><code><span class="keyword">module</span> <a href="Ast_convenience/index.html">Ast_convenience</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>